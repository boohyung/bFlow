/*
 * This source file contains a Verilog description of an IP core
 * automatically generated by the SPIRAL HDL Generator.
 *
 * This product includes a hardware design developed by Carnegie Mellon University.
 *
 * Copyright (c) 2005-2011 by Peter A. Milder for the SPIRAL Project,
 * Carnegie Mellon University
 *
 * For more information, see the SPIRAL project website at:
 *   http://www.spiral.net
 *
 * This design is provided for internal, non-commercial research use only
 * and is not for redistribution, with or without modifications.
 * 
 * You may not use the name "Carnegie Mellon University" or derivations
 * thereof to endorse or promote products derived from this software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS OR BE ERROR-FREE AND ANY
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * TITLE, OR NON-INFRINGEMENT.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * BE LIABLE FOR ANY DAMAGES, INCLUDING BUT NOT LIMITED TO DIRECT, INDIRECT,
 * SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN
 * ANY WAY CONNECTED WITH THIS SOFTWARE (WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT OR OTHERWISE).
 *
 */

//   Input/output stream: 2 complex words per cycle
//   Throughput: one transform every 2 cycles
//   Latency: 36 cycles

//   Resources required:
//     4 multipliers (4 x 4 bit)

// Generated on Thu Feb 26 00:09:18 EST 2015

// Latency: 36 clock cycles
// Throughput: 1 transform every 2 cycles


// We use an interleaved complex data format.  X0 represents the
// real portion of the first input, and X1 represents the imaginary
// portion.  The X variables are system inputs and the Y variables
// are system outputs.

// The design uses a system of flag signals to indicate the
// beginning of the input and output data streams.  The 'next'
// input (asserted high), is used to instruct the system that the
// input stream will begin on the following cycle.

// This system has a 'gap' of 2 cycles.  This means that
// 2 cycles must elapse between the beginning of the input
// vectors.

// The output signal 'next_out' (also asserted high) indicates
// that the output vector will begin streaming out of the system
 // on the following cycle.

// The system has a latency of 36 cycles.  This means that
// the 'next_out' will be asserted 36 cycles after the user
// asserts 'next'.

// The simple testbench below will demonstrate the timing for loading
// and unloading data vectors.
// The system reset signal is asserted high.

// Please note: when simulating floating point code, you must include
// Xilinx's DSP slice simulation module.


// Latency: 36
// Gap: 2
// module_name_is:dft_top
module spiraldft_4_4_stream_date(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [3:0] X0,
      X1,
      X2,
      X3;

   output [3:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [3:0] t0_0;
   wire [3:0] t0_1;
   wire [3:0] t0_2;
   wire [3:0] t0_3;
   wire next_0;
   wire [3:0] t1_0;
   wire [3:0] t1_1;
   wire [3:0] t1_2;
   wire [3:0] t1_3;
   wire next_1;
   wire [3:0] t2_0;
   wire [3:0] t2_1;
   wire [3:0] t2_2;
   wire [3:0] t2_3;
   wire next_2;
   wire [3:0] t3_0;
   wire [3:0] t3_1;
   wire [3:0] t3_2;
   wire [3:0] t3_3;
   wire next_3;
   wire [3:0] t4_0;
   wire [3:0] t4_1;
   wire [3:0] t4_2;
   wire [3:0] t4_3;
   wire next_4;
   wire [3:0] t5_0;
   wire [3:0] t5_1;
   wire [3:0] t5_2;
   wire [3:0] t5_3;
   wire next_5;
   wire [3:0] t6_0;
   wire [3:0] t6_1;
   wire [3:0] t6_2;
   wire [3:0] t6_3;
   wire next_6;
   assign t0_0 = X0;
   assign Y0 = t6_0;
   assign t0_1 = X1;
   assign Y1 = t6_1;
   assign t0_2 = X2;
   assign Y2 = t6_2;
   assign t0_3 = X3;
   assign Y3 = t6_3;
   assign next_0 = next;
   assign next_out = next_6;

// latency=8, gap=2
   rc58820 stage0(.clk(clk), .reset(reset), .next(next_0), .next_out(next_1),
    .X0(t0_0), .Y0(t1_0),
    .X1(t0_1), .Y1(t1_1),
    .X2(t0_2), .Y2(t1_2),
    .X3(t0_3), .Y3(t1_3));


// latency=2, gap=2
   codeBlock58822 stage1(.clk(clk), .reset(reset), .next_in(next_1), .next_out(next_2),
       .X0_in(t1_0), .Y0(t2_0),
       .X1_in(t1_1), .Y1(t2_1),
       .X2_in(t1_2), .Y2(t2_2),
       .X3_in(t1_3), .Y3(t2_3));


// latency=8, gap=2
   DirSum_59079 stage2(.next(next_2), .clk(clk), .reset(reset), .next_out(next_3),
       .X0(t2_0), .Y0(t3_0),
       .X1(t2_1), .Y1(t3_1),
       .X2(t2_2), .Y2(t3_2),
       .X3(t2_3), .Y3(t3_3));


// latency=8, gap=2
   rc59084 stage3(.clk(clk), .reset(reset), .next(next_3), .next_out(next_4),
    .X0(t3_0), .Y0(t4_0),
    .X1(t3_1), .Y1(t4_1),
    .X2(t3_2), .Y2(t4_2),
    .X3(t3_3), .Y3(t4_3));


// latency=2, gap=2
   codeBlock59086 stage4(.clk(clk), .reset(reset), .next_in(next_4), .next_out(next_5),
       .X0_in(t4_0), .Y0(t5_0),
       .X1_in(t4_1), .Y1(t5_1),
       .X2_in(t4_2), .Y2(t5_2),
       .X3_in(t4_3), .Y3(t5_3));


// latency=8, gap=2
   rc59168 stage5(.clk(clk), .reset(reset), .next(next_5), .next_out(next_6),
    .X0(t5_0), .Y0(t6_0),
    .X1(t5_1), .Y1(t6_1),
    .X2(t5_2), .Y2(t6_2),
    .X3(t5_3), .Y3(t6_3));


endmodule

// Latency: 8
// Gap: 2
module rc58820(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [3:0] X0,
      X1,
      X2,
      X3;

   output [3:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [7:0] t0;
   wire [7:0] s0;
   assign t0 = {X0, X1};
   wire [7:0] t1;
   wire [7:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[7:4];
   assign Y1 = s0[3:0];
   assign Y2 = s1[7:4];
   assign Y3 = s1[3:0];

   perm58818 instPerm59385(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet58818(itr, clk, ct
,       x0, y0
,       x1, y1
);

    parameter width = 8;

    input [0:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    wire [width-1:0] t0_0, t0_1;
    reg [width-1:0] t1_0, t1_1;

    reg [0:0] control;

    always @(posedge clk) begin
      case(ct)
        1'd0: control <= 1'b1;
        1'd1: control <= 1'b0;
      endcase
   end

// synthesis attribute rom_style of control is "block"
   reg [0:0] control0;
    always @(posedge clk) begin
       control0 <= control;
    end
    assign t0_0 = x0;
    assign t0_1 = x1;
   always @(posedge clk) begin
         t1_0 <= (control0[0] == 0) ? t0_0 : t0_1;
         t1_1 <= (control0[0] == 0) ? t0_1 : t0_0;
   end
    always @(posedge clk) begin
        y0 <= t1_0;
        y1 <= t1_1;
    end
endmodule

// Latency: 8
// Gap: 2
module perm58818(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter width = 8;

   parameter depth = 2;

   parameter addrbits = 1;

   parameter muxbits = 1;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm0;
   assign tm0 = 0;

shiftRegFIFO #(3, 1) shiftFIFO_59390(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_59391(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);

shiftRegFIFO #(1, 1) shiftFIFO_59400(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_59401(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(2, 1) shiftFIFO_59402(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_59403(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_59406(.X(tm0), .Y(tm0_d), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_59409(.X(tm0_d), .Y(tm0_dd), .clk(clk));
//   shiftRegFIFO #(depth-1, 1) n1(next, next2, clk);
//   shiftRegFIFO #(3, 1)       n2(next2, next3, clk);
//   shiftRegFIFO #(depth, 1)   n3(next3, next4, clk);
//   shiftRegFIFO #(1, 1)       n4(next4, next_out, clk);   
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(3, 1) shiftFIFO_59414(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(4, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm0_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd0 <= 1;
	     {1'd0,  1'd1}: s1rd0 <= 0;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "block"
   always @(posedge clk) begin
      case({tm0_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd1 <= 0;
	     {1'd0,  1'd1}: s1rd1 <= 1;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "block"
    swNet58818 sw(tm0_d, clk, muxCycle, t0, s0, t1, s1);

   always @(posedge clk) begin
      case({tm0_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr0 <= 1;
	      {1'd0, 1'd1}: s2wr0 <= 0;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "block"
   always @(posedge clk) begin
      case({tm0_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr1 <= 0;
	      {1'd0, 1'd1}: s2wr1 <= 1;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "block"
endmodule




module memMod(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is block

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 



module memMod_dist(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is distributed

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 

module shiftRegFIFO(X, Y, clk);
   parameter depth=1, width=1;

   output [width-1:0] Y;
   input  [width-1:0] X;
   input              clk;

   reg [width-1:0]    mem [depth-1:0];
   integer            index;

   assign Y = mem[depth-1];

   always @ (posedge clk) begin
      for(index=1;index<depth;index=index+1) begin
         mem[index] <= mem[index-1];
      end
      mem[0]<=X;
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock58822(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [3:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [3:0] X0,
      X1,
      X2,
      X3;

   output [3:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_59417(.X(next), .Y(next_out), .clk(clk));


   wire signed [3:0] a69;
   wire signed [3:0] a70;
   wire signed [3:0] a71;
   wire signed [3:0] a72;
   wire signed [3:0] t45;
   wire signed [3:0] t46;
   wire signed [3:0] t47;
   wire signed [3:0] t48;
   wire signed [3:0] Y0;
   wire signed [3:0] Y1;
   wire signed [3:0] Y2;
   wire signed [3:0] Y3;


   assign a69 = X0;
   assign a70 = X2;
   assign a71 = X1;
   assign a72 = X3;
   assign Y0 = t45;
   assign Y1 = t46;
   assign Y2 = t47;
   assign Y3 = t48;

    addfxp #(4, 1) add58834(.a(a69), .b(a70), .clk(clk), .q(t45));    // 0
    addfxp #(4, 1) add58849(.a(a71), .b(a72), .clk(clk), .q(t46));    // 0
    subfxp #(4, 1) sub58864(.a(a69), .b(a70), .clk(clk), .q(t47));    // 0
    subfxp #(4, 1) sub58879(.a(a71), .b(a72), .clk(clk), .q(t48));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 8
// Gap: 2
module DirSum_59079(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [0:0] i1;

   input [3:0] X0,
      X1,
      X2,
      X3;

   output [3:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i1 <= 0;
      end
      else begin
         if (next == 1)
            i1 <= 0;
         else if (i1 == 1)
            i1 <= 0;
         else
            i1 <= i1 + 1;
      end
   end

   codeBlock58901 codeBlockIsnt59418(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i1_in(i1),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D4_59065(addr, out, clk);
   input clk;
   output [3:0] out;
   reg [3:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 4'h0;
      1: out3 <= 4'h4;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D2_59073(addr, out, clk);
   input clk;
   output [3:0] out;
   reg [3:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 4'h4;
      1: out3 <= 4'h0;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 8
// Gap: 1
module codeBlock58901(clk, reset, next_in, next_out,
   i1_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [0:0] i1_in;
   reg [0:0] i1;

   input [3:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [3:0] X0,
      X1,
      X2,
      X3;

   output [3:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_59421(.X(next), .Y(next_out), .clk(clk));


   wire signed [3:0] a53;
   wire signed [3:0] a42;
   wire signed [3:0] a56;
   wire signed [3:0] a46;
   wire signed [3:0] a57;
   wire signed [3:0] a58;
   reg signed [3:0] tm29;
   reg signed [3:0] tm33;
   reg signed [3:0] tm45;
   reg signed [3:0] tm52;
   reg signed [3:0] tm30;
   reg signed [3:0] tm34;
   reg signed [3:0] tm46;
   reg signed [3:0] tm53;
   wire signed [3:0] tm3;
   wire signed [3:0] a47;
   wire signed [3:0] tm4;
   wire signed [3:0] a49;
   reg signed [3:0] tm31;
   reg signed [3:0] tm35;
   reg signed [3:0] tm47;
   reg signed [3:0] tm54;
   reg signed [3:0] tm11;
   reg signed [3:0] tm12;
   reg signed [3:0] tm32;
   reg signed [3:0] tm36;
   reg signed [3:0] tm48;
   reg signed [3:0] tm55;
   reg signed [3:0] tm49;
   reg signed [3:0] tm56;
   wire signed [3:0] a48;
   wire signed [3:0] a50;
   wire signed [3:0] a51;
   wire signed [3:0] a52;
   reg signed [3:0] tm50;
   reg signed [3:0] tm57;
   wire signed [3:0] Y0;
   wire signed [3:0] Y1;
   wire signed [3:0] Y2;
   wire signed [3:0] Y3;
   reg signed [3:0] tm51;
   reg signed [3:0] tm58;


   assign a53 = X0;
   assign a42 = a53;
   assign a56 = X1;
   assign a46 = a56;
   assign a57 = X2;
   assign a58 = X3;
   assign a47 = tm3;
   assign a49 = tm4;
   assign Y0 = tm51;
   assign Y1 = tm58;

   D4_59065 instD4inst0_59065(.addr(i1[0:0]), .out(tm4), .clk(clk));

   D2_59073 instD2inst0_59073(.addr(i1[0:0]), .out(tm3), .clk(clk));

    multfix #(4, 2) m59000(.a(tm11), .b(tm32), .clk(clk), .q_sc(a48), .q_unsc(), .rst(reset));
    multfix #(4, 2) m59022(.a(tm12), .b(tm36), .clk(clk), .q_sc(a50), .q_unsc(), .rst(reset));
    multfix #(4, 2) m59040(.a(tm12), .b(tm32), .clk(clk), .q_sc(a51), .q_unsc(), .rst(reset));
    multfix #(4, 2) m59051(.a(tm11), .b(tm36), .clk(clk), .q_sc(a52), .q_unsc(), .rst(reset));
    subfxp #(4, 1) sub59029(.a(a48), .b(a50), .clk(clk), .q(Y2));    // 6
    addfxp #(4, 1) add59058(.a(a51), .b(a52), .clk(clk), .q(Y3));    // 6


   always @(posedge clk) begin
      if (reset == 1) begin
         tm11 <= 0;
         tm32 <= 0;
         tm12 <= 0;
         tm36 <= 0;
         tm12 <= 0;
         tm32 <= 0;
         tm11 <= 0;
         tm36 <= 0;
      end
      else begin
         i1 <= i1_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm29 <= a57;
         tm33 <= a58;
         tm45 <= a42;
         tm52 <= a46;
         tm30 <= tm29;
         tm34 <= tm33;
         tm46 <= tm45;
         tm53 <= tm52;
         tm31 <= tm30;
         tm35 <= tm34;
         tm47 <= tm46;
         tm54 <= tm53;
         tm11 <= a47;
         tm12 <= a49;
         tm32 <= tm31;
         tm36 <= tm35;
         tm48 <= tm47;
         tm55 <= tm54;
         tm49 <= tm48;
         tm56 <= tm55;
         tm50 <= tm49;
         tm57 <= tm56;
         tm51 <= tm50;
         tm58 <= tm57;
      end
   end
endmodule

// Latency: 8
// Gap: 2
module rc59084(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [3:0] X0,
      X1,
      X2,
      X3;

   output [3:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [7:0] t0;
   wire [7:0] s0;
   assign t0 = {X0, X1};
   wire [7:0] t1;
   wire [7:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[7:4];
   assign Y1 = s0[3:0];
   assign Y2 = s1[7:4];
   assign Y3 = s1[3:0];

   perm59082 instPerm59422(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet59082(itr, clk, ct
,       x0, y0
,       x1, y1
);

    parameter width = 8;

    input [0:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    wire [width-1:0] t0_0, t0_1;
    reg [width-1:0] t1_0, t1_1;

    reg [0:0] control;

    always @(posedge clk) begin
      case(ct)
        1'd0: control <= 1'b1;
        1'd1: control <= 1'b0;
      endcase
   end

// synthesis attribute rom_style of control is "block"
   reg [0:0] control0;
    always @(posedge clk) begin
       control0 <= control;
    end
    assign t0_0 = x0;
    assign t0_1 = x1;
   always @(posedge clk) begin
         t1_0 <= (control0[0] == 0) ? t0_0 : t0_1;
         t1_1 <= (control0[0] == 0) ? t0_1 : t0_0;
   end
    always @(posedge clk) begin
        y0 <= t1_0;
        y1 <= t1_1;
    end
endmodule

// Latency: 8
// Gap: 2
module perm59082(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter width = 8;

   parameter depth = 2;

   parameter addrbits = 1;

   parameter muxbits = 1;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm5;
   assign tm5 = 0;

shiftRegFIFO #(3, 1) shiftFIFO_59427(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_59428(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);

shiftRegFIFO #(1, 1) shiftFIFO_59437(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_59438(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(2, 1) shiftFIFO_59439(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_59440(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_59443(.X(tm5), .Y(tm5_d), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_59446(.X(tm5_d), .Y(tm5_dd), .clk(clk));
//   shiftRegFIFO #(depth-1, 1) n1(next, next2, clk);
//   shiftRegFIFO #(3, 1)       n2(next2, next3, clk);
//   shiftRegFIFO #(depth, 1)   n3(next3, next4, clk);
//   shiftRegFIFO #(1, 1)       n4(next4, next_out, clk);   
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(3, 1) shiftFIFO_59451(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(4, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm5_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd0 <= 1;
	     {1'd0,  1'd1}: s1rd0 <= 0;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "block"
   always @(posedge clk) begin
      case({tm5_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd1 <= 0;
	     {1'd0,  1'd1}: s1rd1 <= 1;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "block"
    swNet59082 sw(tm5_d, clk, muxCycle, t0, s0, t1, s1);

   always @(posedge clk) begin
      case({tm5_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr0 <= 1;
	      {1'd0, 1'd1}: s2wr0 <= 0;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "block"
   always @(posedge clk) begin
      case({tm5_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr1 <= 0;
	      {1'd0, 1'd1}: s2wr1 <= 1;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "block"
endmodule


// Latency: 2
// Gap: 1
module codeBlock59086(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [3:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [3:0] X0,
      X1,
      X2,
      X3;

   output [3:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_59454(.X(next), .Y(next_out), .clk(clk));


   wire signed [3:0] a9;
   wire signed [3:0] a10;
   wire signed [3:0] a11;
   wire signed [3:0] a12;
   wire signed [3:0] t21;
   wire signed [3:0] t22;
   wire signed [3:0] t23;
   wire signed [3:0] t24;
   wire signed [3:0] Y0;
   wire signed [3:0] Y1;
   wire signed [3:0] Y2;
   wire signed [3:0] Y3;


   assign a9 = X0;
   assign a10 = X2;
   assign a11 = X1;
   assign a12 = X3;
   assign Y0 = t21;
   assign Y1 = t22;
   assign Y2 = t23;
   assign Y3 = t24;

    addfxp #(4, 1) add59098(.a(a9), .b(a10), .clk(clk), .q(t21));    // 0
    addfxp #(4, 1) add59113(.a(a11), .b(a12), .clk(clk), .q(t22));    // 0
    subfxp #(4, 1) sub59128(.a(a9), .b(a10), .clk(clk), .q(t23));    // 0
    subfxp #(4, 1) sub59143(.a(a11), .b(a12), .clk(clk), .q(t24));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 8
// Gap: 2
module rc59168(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [3:0] X0,
      X1,
      X2,
      X3;

   output [3:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [7:0] t0;
   wire [7:0] s0;
   assign t0 = {X0, X1};
   wire [7:0] t1;
   wire [7:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[7:4];
   assign Y1 = s0[3:0];
   assign Y2 = s1[7:4];
   assign Y3 = s1[3:0];

   perm59166 instPerm59455(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet59166(itr, clk, ct
,       x0, y0
,       x1, y1
);

    parameter width = 8;

    input [0:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    wire [width-1:0] t0_0, t0_1;
    reg [width-1:0] t1_0, t1_1;

    reg [0:0] control;

    always @(posedge clk) begin
      case(ct)
        1'd0: control <= 1'b1;
        1'd1: control <= 1'b0;
      endcase
   end

// synthesis attribute rom_style of control is "block"
   reg [0:0] control0;
    always @(posedge clk) begin
       control0 <= control;
    end
    assign t0_0 = x0;
    assign t0_1 = x1;
   always @(posedge clk) begin
         t1_0 <= (control0[0] == 0) ? t0_0 : t0_1;
         t1_1 <= (control0[0] == 0) ? t0_1 : t0_0;
   end
    always @(posedge clk) begin
        y0 <= t1_0;
        y1 <= t1_1;
    end
endmodule

// Latency: 8
// Gap: 2
module perm59166(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter width = 8;

   parameter depth = 2;

   parameter addrbits = 1;

   parameter muxbits = 1;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm6;
   assign tm6 = 0;

shiftRegFIFO #(3, 1) shiftFIFO_59460(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_59461(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);

shiftRegFIFO #(1, 1) shiftFIFO_59470(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_59471(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(2, 1) shiftFIFO_59472(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_59473(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_59476(.X(tm6), .Y(tm6_d), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_59479(.X(tm6_d), .Y(tm6_dd), .clk(clk));
//   shiftRegFIFO #(depth-1, 1) n1(next, next2, clk);
//   shiftRegFIFO #(3, 1)       n2(next2, next3, clk);
//   shiftRegFIFO #(depth, 1)   n3(next3, next4, clk);
//   shiftRegFIFO #(1, 1)       n4(next4, next_out, clk);   
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(3, 1) shiftFIFO_59484(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(4, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm6_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd0 <= 1;
	     {1'd0,  1'd1}: s1rd0 <= 0;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "block"
   always @(posedge clk) begin
      case({tm6_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd1 <= 0;
	     {1'd0,  1'd1}: s1rd1 <= 1;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "block"
    swNet59166 sw(tm6_d, clk, muxCycle, t0, s0, t1, s1);

   always @(posedge clk) begin
      case({tm6_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr0 <= 1;
	      {1'd0, 1'd1}: s2wr0 <= 0;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "block"
   always @(posedge clk) begin
      case({tm6_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr1 <= 0;
	      {1'd0, 1'd1}: s2wr1 <= 1;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "block"
endmodule



						module multfix(clk, rst, a, b, q_sc, q_unsc);
						   parameter WIDTH=35, CYCLES=6;

						   input signed [WIDTH-1:0]    a,b;
						   output [WIDTH-1:0]          q_sc;
						   output [WIDTH-1:0]              q_unsc;

						   input                       clk, rst;
						   
						   reg signed [2*WIDTH-1:0]    q[CYCLES-1:0];
						   wire signed [2*WIDTH-1:0]   res;   
						   integer                     i;

						   assign                      res = q[CYCLES-1];   
						   
						   assign                      q_unsc = res[WIDTH-1:0];
						   assign                      q_sc = {res[2*WIDTH-1], res[2*WIDTH-4:WIDTH-2]};
						      
						   always @(posedge clk) begin
						      q[0] <= a * b;
						      for (i = 1; i < CYCLES; i=i+1) begin
						         q[i] <= q[i-1];
						      end
						   end
						                  
						endmodule 
module addfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a+b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
   
endmodule

module subfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a-b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
  
endmodule
