/*------------------------------------------------------------------------------
 * This code was generated by Spiral IIR Filter Generator, www.spiral.net
 * Copyright (c) 2006, Carnegie Mellon University
 * All rights reserved.
 * The code is distributed under a BSD style license
 * (see http://www.opensource.org/licenses/bsd-license.php)
 *------------------------------------------------------------------------------ */
/* ./iirGen.pl -A 256 0 235 0 49 0 1 0 -B 4 -29 89 -148 148 -89 29 -4 -moduleName acm_filter -fractionalBits 8 -bitWidth 32 -inData inData -inReg -outReg -outData outData -clk clk -reset reset -reset_edge negedge -filterForm 1 -outFile ../outputs/filter_1426607782.v */

module acm_filter_firBlock_left_MultiplyBlock (
    X,
    Y1,
    Y2,
    Y3,
    Y4,
    Y5,
    Y6,
    Y7,
    Y8
);

  // Port mode declarations:
  input signed   [31:0] X;
  output signed  [31:0]
    Y1,
    Y2,
    Y3,
    Y4,
    Y5,
    Y6,
    Y7,
    Y8;

  wire [31:0] Y [0:7];

  assign Y1 = Y[0];
  assign Y2 = Y[1];
  assign Y3 = Y[2];
  assign Y4 = Y[3];
  assign Y5 = Y[4];
  assign Y6 = Y[5];
  assign Y7 = Y[6];
  assign Y8 = Y[7];

  //Multipliers:

  wire signed [39:0]
    w1,
    w32,
    w33,
    w4,
    w29,
    w37,
    w8,
    w7,
    w56,
    w89,
    w4_,
    w89_,
    w148,
    w148_,
    w29_;

  assign w1 = X;
  assign w148 = w37 << 2;
  assign w148_ = -1 * w148;
  assign w29 = w33 - w4;
  assign w29_ = -1 * w29;
  assign w32 = w1 << 5;
  assign w33 = w1 + w32;
  assign w37 = w33 + w4;
  assign w4 = w1 << 2;
  assign w4_ = -1 * w4;
  assign w56 = w7 << 3;
  assign w7 = w8 - w1;
  assign w8 = w1 << 3;
  assign w89 = w33 + w56;
  assign w89_ = -1 * w89;

  assign Y[0] = w4_[39:8];
  assign Y[1] = w29[39:8];
  assign Y[2] = w89_[39:8];
  assign Y[3] = w148[39:8];
  assign Y[4] = w148_[39:8];
  assign Y[5] = w89[39:8];
  assign Y[6] = w29_[39:8];
  assign Y[7] = w4[39:8];

  //acm_filter_firBlock_left_MultiplyBlock area estimate = 18993.7442092559;
endmodule //acm_filter_firBlock_left_MultiplyBlock




module acm_filter_firBlock_left (
    X,
    clk,
    Y,
    reset
);

  // Port mode declarations:
  input   [31:0] X;
  input    clk;
  output  [31:0] Y;
  input    reset;

  //registerOut
  reg [31:0] Y;
  wire [31:0] Y_in;

  always@(posedge clk or negedge reset) begin
    if(~reset) begin
      Y <= 32'h00000000;
    end  else begin
      Y <= Y_in;
    end
  end

  wire [31:0] multProducts [0:7];

  acm_filter_firBlock_left_MultiplyBlock my_acm_filter_firBlock_left_MultiplyBlock(
    .X(X),
    .Y1(multProducts[0]),
    .Y2(multProducts[1]),
    .Y3(multProducts[2]),
    .Y4(multProducts[3]),
    .Y5(multProducts[4]),
    .Y6(multProducts[5]),
    .Y7(multProducts[6]),
    .Y8(multProducts[7])
  );

  reg [31:0] firStep[0:6];

  always@(posedge clk or negedge reset) begin
    if(~reset) begin
      firStep[0] <= 32'h00000000;
      firStep[1] <= 32'h00000000;
      firStep[2] <= 32'h00000000;
      firStep[3] <= 32'h00000000;
      firStep[4] <= 32'h00000000;
      firStep[5] <= 32'h00000000;
      firStep[6] <= 32'h00000000;
    end
    else begin
      firStep[0] <=  multProducts[0];
      firStep[1] <=  firStep[0] + multProducts[1];
      firStep[2] <=  firStep[1] + multProducts[2];
      firStep[3] <=  firStep[2] + multProducts[3];
      firStep[4] <=  firStep[3] + multProducts[4];
      firStep[5] <=  firStep[4] + multProducts[5];
      firStep[6] <=  firStep[5] + multProducts[6];
    end
  end

  assign Y_in = firStep[6]+ multProducts[7];
  //acm_filter_firBlock_left area estimate = 53947.5563672765;
endmodule //acm_filter_firBlock_left



/* Warning: zero-valued filter taps have been optimized away. */

module acm_filter_firBlock_right_MultiplyBlock (
    X,
    Y1,
    Y2,
    Y3,
    Y4,
    Y5,
    Y6
);

  // Port mode declarations:
  input signed   [31:0] X;
  output signed  [31:0]
    Y1,
    Y2,
    Y3,
    Y4,
    Y5,
    Y6;

  wire [31:0] Y [0:5];

  assign Y1 = Y[0];
  assign Y2 = Y[1];
  assign Y3 = Y[2];
  assign Y4 = Y[3];
  assign Y5 = Y[4];
  assign Y6 = Y[5];

  //Multipliers:

  wire signed [39:0]
    w1,
    w0,
    w4,
    w3,
    w48,
    w49,
    w24,
    w21,
    w256,
    w235,
    w1_,
    w49_,
    w235_;

  assign w1 = X;
  assign w0 = 0;
  assign w1_ = -1 * w1;
  assign w21 = w24 - w3;
  assign w235 = w256 - w21;
  assign w235_ = -1 * w235;
  assign w24 = w3 << 3;
  assign w256 = w1 << 8;
  assign w3 = w4 - w1;
  assign w4 = w1 << 2;
  assign w48 = w3 << 4;
  assign w49 = w1 + w48;
  assign w49_ = -1 * w49;

  assign Y[0] = w1_[39:8];
  assign Y[1] = w0[39:8];
  assign Y[2] = w49_[39:8];
  assign Y[3] = w0[39:8];
  assign Y[4] = w235_[39:8];
  assign Y[5] = w0[39:8];

  //acm_filter_firBlock_right_MultiplyBlock area estimate = 14915.5775623221;
endmodule //acm_filter_firBlock_right_MultiplyBlock




module acm_filter_firBlock_right (
    X,
    clk,
    Y,
    reset
);

  // Port mode declarations:
  input   [31:0] X;
  input    clk;
  output  [31:0] Y;
  input    reset;

  //registerOut
  reg [31:0] Y;
  wire [31:0] Y_in;

  always@(posedge clk or negedge reset) begin
    if(~reset) begin
      Y <= 32'h00000000;
    end  else begin
      Y <= Y_in;
    end
  end

  wire [31:0] multProducts [0:5];

  acm_filter_firBlock_right_MultiplyBlock my_acm_filter_firBlock_right_MultiplyBlock(
    .X(X),
    .Y1(multProducts[0]),
    .Y2(multProducts[1]),
    .Y3(multProducts[2]),
    .Y4(multProducts[3]),
    .Y5(multProducts[4]),
    .Y6(multProducts[5])
  );

  reg [31:0] firStep[0:4];

  always@(posedge clk or negedge reset) begin
    if(~reset) begin
      firStep[0] <= 32'h00000000;
      firStep[1] <= 32'h00000000;
      firStep[2] <= 32'h00000000;
      firStep[3] <= 32'h00000000;
      firStep[4] <= 32'h00000000;
    end
    else begin
      firStep[0] <=  multProducts[0];
      firStep[1] <=  firStep[0] + multProducts[1];
      firStep[2] <=  firStep[1] + multProducts[2];
      firStep[3] <=  firStep[2] + multProducts[3];
      firStep[4] <=  firStep[3] + multProducts[4];
    end
  end

  assign Y_in = firStep[4]+ multProducts[5];
  //acm_filter_firBlock_right area estimate = 33995.8084926339;
endmodule //acm_filter_firBlock_right




module acm_filter (
    inData,
    clk,
    outData,
    reset
);

  // Port mode declarations:
  input   [31:0] inData;
  input    clk;
  output  [31:0] outData;
  input    reset;

  //registerIn
  reg [31:0] inData_in;

  always@(posedge clk or negedge reset) begin
    if(~reset) begin
      inData_in <= 32'h00000000;
    end  else begin
      inData_in <= inData;
    end
  end

  //registerOut
  reg [31:0] outData;
  wire [31:0] outData_in;

  always@(posedge clk or negedge reset) begin
    if(~reset) begin
      outData <= 32'h00000000;
    end  else begin
      outData <= outData_in;
    end
  end

  wire [31:0] leftOut, rightOut;

  acm_filter_firBlock_left my_acm_filter_firBlock_left(
    .X(inData_in),
    .Y(leftOut),
    .clk(clk),
    .reset(reset)
);

  acm_filter_firBlock_right my_acm_filter_firBlock_right(
    .X(outData_in),
    .Y(rightOut),
    .clk(clk),
    .reset(reset)
);

  assign outData_in = leftOut + rightOut;

  //acm_filter area estimate = 95035.2498559839;
endmodule //acm_filter

